<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.12">
  <POU Name="FB_MotorMonitoringAX5000" Id="{45819aca-0901-4f01-b2b6-9fa59a271882}" SpecialFunc="None">
    <Declaration><![CDATA[//==================================================================================================
//							Beckhoff Automation Poland
//									23.05.2018
//	Blok funkcyjny pozwala na monitorowanie i ograniczanie momentu oraz monitoring parametru I2T dla AX5xxx.
//	Zmienne do zlinkowania zadeklarowane są wewnątrz bloku.
//	Ograniczenie i monitorowanie momentu
//	Ograniczenie momentu podawane jest przez wejście rTorqueLimit.
//	Na wyjściu podana jest wartość surowa w %, jak i przeskalowana na A (prąd) i Nm (moment).
//	Blok zwraca wartości bieżące, przefiltrowane i maksymalne.
//	Wartości maksymalne mogą być wyzerowane za pomocą zmiennej bReset.
//	Wewnętrznie wykorzystany jest blok FB_FilterEx.
//	I2T: 	Określamy okno czasowe pomiaru
//
// 	v1.1	|| TC v 3.1.4022.16		|| - optymalizacja kodu
//  v1.0	|| TC v 3.1.4022.16		|| bazuje na FB_TorqueMonitoringEx2, dodane wyjscia zgodne z blokiem do AX8000 
//==================================================================================================
FUNCTION_BLOCK FB_MotorMonitoringAX5000
VAR CONSTANT
	rTorqueLimitLow					: REAL 		:= 0.01;				// Low limit used for bipolar torque limit value
	rTorqueLimitHigh				: REAL		:= 100.0;				// High limit used for bipolar torque limit value
END_VAR
VAR_INPUT
	bReset							: BOOL;
	rTorqueLimit					: REAL 		:= rTorqueLimitHigh; 	// Bipolar torque limit: 0-500%, resolution 0.1%, value goes to: 16#6072 (Ch A)/ 16#6872 (Ch B)
	tI2T_Window						: TIME 		:= T#1M;
END_VAR
VAR_OUTPUT
	bError							: BOOL; 							// Communication error *)
	iAdsErrId						: UINT;								// Forwarded output FB_SoeRead
	iSercosErrId					: UINT;								// Forwarded output FB_SoeRead
	bInitialized					: BOOL;								// TRUE - Motor data read without errors, so it's possible to calculate torqe and current values in metric units
	bWarning						: BOOL;								// Overcurrent (rCurrentF > rRatedCurrent)
	rWarningCurrent					: REAL; 							// P_0_0093_Value in [A]
	rTorquePerc						: REAL;								// [%]
	rTorquePercMax					: REAL;								// Max [%]	
	rTorque							: REAL; 							// [Nm]
	rTorqueF						: REAL;								// Filtered
	rTorqueMax						: REAL;								// Max
	rCurrent						: REAL; 							// [A]
	rCurrentF						: REAL;								// Filtered
	rCurrentMax						: REAL;								// Max
	rI2T							: REAL; 							// % nominal
	rI2TMax							: REAL;
END_VAR
VAR_IN_OUT
	Axis							: AXIS_REF;
END_VAR
VAR
	fbSoERead						: FB_SoeRead;
	iStep							: INT;
	arr_S_0_0030_Value				: ARRAY [1..66] OF BYTE;
	S_0_0030_Value					: STRING;
	bDriveFirmware_2_10				: BOOL;
	P_0_0092_Value					: DWORD;
	P_0_0093_Value					: DWORD;
	P_0_0070_Value					: DWORD;
	S_0_0111_Value					: DWORD;
	uiBipolarTorqueLimitValue AT %Q*	: UINT; 								// Raw data, linked to Bipolar torque limit value MDT, S-0-0092
	iTorque 							: INT; 								// -1000 .. 1000 - RAW values the same as process image
	rTorqueRAW						: REAL; 							// -1000 .. 1000 - RAW values the same as process image	
	rPeakCurrent					: REAL; 							// P_0_0092_Value in [A]
	rFactor							: REAL; 							// iTorque -1000..1000 --> - rPeakCurrent .. rPeakCurrent
	rContinuousStallTorque			: REAL; 							// P_0_0070_Value [Nm]
	rContinuousStallCurrent			: REAL; 							// S_0_0111_Value [A]
	rTorqueConstant					: REAL; 							// P_0_0070_Value/S_0_0111_Value [Nm/A]
	fbFilterEx						: FB_FilterEx;

	rI2T_pom						: REAL 		:= 0.0;
	rI2T_Window						: REAL;
	bFlag_1							: BOOL 		:= FALSE;
	iCycles							: INT;
	rCycleTime_pom					: REAL;
	iCounter						: INT;
	rBuffer							: ARRAY[1..100] OF REAL;
	rBuffer_2						: ARRAY[1..100] OF REAL;

	rCycleTime						: REAL;								// Ustawiony czas Tasku w ms
	fbGETCURTASKINDEX   			: GETCURTASKINDEX;					// Blok sprawdzajcy numer Tasku
	BIndex							: BYTE;								// Nr Tasku
	tonReset						: TON;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[CASE iStep OF
	0: (*Init*)
		bError 						:= FALSE;
		bInitialized				:= FALSE;
		iAdsErrId 					:= 0;
		iSercosErrId				:= 0;
		iStep 						:= iStep + 10;
	
	10: (* Read S_0_0030 *)
		fbSoERead.Idn 				:= S_0_IDN + 30;
		fbSoERead.Element			:= EC_SOE_ELEMENT_VALUE;
		fbSoERead.pDstBuf			:= ADR(arr_S_0_0030_Value);
		fbSoERead.BufLen			:= SIZEOF(arr_S_0_0030_Value);
		fbSoERead.Execute			:= TRUE;
		iStep 						:= iStep + 10;
	
	20:	(* Read Drive firmware version *)
		IF NOT fbSoERead.Busy AND NOT fbSoERead.Error THEN
			fbSoERead.Execute		:= FALSE;
			S_0_0030_Value			:= '';																// Set emtpy string for save data
			FOR iCounter := 1 TO 	UINT_TO_BYTE(SIZEOF(arr_S_0_0030_Value)) 	DO
				S_0_0030_Value		:= CONCAT(S_0_0030_Value, F_ToCHR(arr_S_0_0030_Value[iCounter]));	// Translate ASCII to string 
			END_FOR
			bDriveFirmware_2_10 	:= INT_TO_BOOL(FIND(S_0_0030_Value,'Firmware: v2.10'));				// Check if firmware 2.10 / 2.06
			iStep 					:= iStep + 10;
		END_IF
		IF fbSoERead.Error THEN
			iStep 					:= 500;
		END_IF

	30: (*Read P_0_0092*)
		fbSoERead.Idn 				:= P_0_IDN + 92;
		fbSoERead.Element			:= EC_SOE_ELEMENT_VALUE;
		fbSoERead.pDstBuf			:= ADR(P_0_0092_Value);
		fbSoERead.BufLen			:= SIZEOF(P_0_0092_Value);
		fbSoERead.Execute			:= TRUE;
		iStep 						:= iStep + 10;

	40:
		IF NOT fbSoERead.Busy AND NOT fbSoERead.Error THEN
			rPeakCurrent 			:= DWORD_TO_REAL(P_0_0092_Value)/1000.0;
			rFactor 				:= DWORD_TO_REAL(P_0_0092_Value)/1000000.0;
			fbSoERead.Execute		:= FALSE;
			iStep 					:= iStep + 10;
		END_IF
		IF fbSoERead.Error THEN
			iStep 					:= 500;
		END_IF
		
	50:
		(*Read P_0_0070*)	
		fbSoERead.Idn 				:= P_0_IDN + 70;
		fbSoERead.Element			:= EC_SOE_ELEMENT_VALUE; 
		fbSoERead.pDstBuf			:= ADR(P_0_0070_Value);
		IF bDriveFirmware_2_10 THEN
			fbSoERead.BufLen		:= 4;
		ELSE
			fbSoERead.BufLen		:= 2;
		END_IF
		fbSoERead.Execute			:= TRUE;
		iStep 						:= iStep + 10;

	60:
		IF NOT fbSoERead.Busy AND NOT fbSoERead.Error THEN
			rContinuousStallTorque 	:= DWORD_TO_REAL(P_0_0070_Value)/100;
			fbSoERead.Execute		:= FALSE;
			iStep 					:= iStep + 10;
		END_IF
		IF fbSoERead.Error OR P_0_0070_Value = 0 THEN
			iStep 					:= 500;
		END_IF

	70: (* Read S_0_0111*)
		fbSoERead.Idn 				:= S_0_IDN + 111;
		fbSoERead.Element			:= EC_SOE_ELEMENT_VALUE;
		fbSoERead.pDstBuf			:= ADR(S_0_0111_Value);
		fbSoERead.BufLen			:= SIZEOF(S_0_0111_Value);
		fbSoERead.Execute			:= TRUE;
		iStep 						:= iStep + 10;

	80:
		IF NOT fbSoERead.Busy AND NOT fbSoERead.Error THEN
			IF S_0_0111_Value <> 0 THEN
				rContinuousStallCurrent := DWORD_TO_REAL(S_0_0111_Value)/1000;
				rTorqueConstant 	:= rContinuousStallTorque/rContinuousStallCurrent;
				fbSoERead.Execute	:= FALSE;
				iStep 				:= iStep + 10;
			ELSE
				iStep				:= 500;
			END_IF
		END_IF
		IF fbSoERead.Error THEN
			iStep 					:= 500;
		END_IF

	90: (* Read P_0_0093*)
		fbSoERead.Idn 				:= P_0_IDN + 93;
		fbSoERead.Element			:= EC_SOE_ELEMENT_VALUE;
		fbSoERead.pDstBuf			:= ADR(P_0_0093_Value);
		fbSoERead.BufLen			:= SIZEOF(P_0_0093_Value);
		fbSoERead.Execute			:= TRUE;
		iStep 						:= iStep + 10;

	100:
		IF NOT fbSoERead.Busy AND NOT fbSoERead.Error THEN
			rWarningCurrent 			:= DWORD_TO_REAL(P_0_0093_Value)/1000;
			fbSoERead.Execute		:= FALSE;
			iStep 					:= iStep + 10;
		END_IF
		IF fbSoERead.Error THEN
			bInitialized			:= TRUE;
			iStep 					:= 500;
		END_IF

	110: (*Calculations*)
		rCurrent 					:= rTorqueRAW * rFactor;
		rTorque 					:= rCurrent * rTorqueConstant;

	500: (* Error Case *)
		iStep 						:= 0;
		fbSoERead(Execute:= FALSE,Axis:= Axis);
		bError 						:= TRUE;
		iAdsErrId 					:= fbSoERead.AdsErrId;
		iSercosErrId				:= fbSoERead.SercosErrId;
		tonReset(IN:= TRUE, PT:= T#1S);
		IF tonReset.Q THEN
			tonReset(IN:= FALSE);
		END_IF
END_CASE
//===================== Limit output torque =====================
IF rTorqueLimit < rTorqueLimitLow THEN
	uiBipolarTorqueLimitValue 			:= REAL_TO_UINT(rTorqueLimitHigh);			// Secure against 0 value - probably empty var connected to input
ELSE
	uiBipolarTorqueLimitValue 			:= REAL_TO_UINT(LIMIT(rTorqueLimitLow,rTorqueLimit,rTorqueLimitHigh))*10;
END_IF

//=============== Read cycle time ===============
fbGETCURTASKINDEX(index => BIndex);
rCycleTime := UDINT_TO_REAL(_TaskInfo[BIndex].CycleTime)/10000.0;

//=============== Calculate algorithm sampling time ===============
rI2T_Window := TIME_TO_REAL(tI2T_Window);
rCycleTime_pom := rI2T_Window/100 ;

IF rCycleTime_pom < rCycleTime THEN
	rCycleTime_pom := rCycleTime;
END_IF

//=============== Filter current value ===============
fbFilterEx(rIn:= rCurrent, tTimeConstant:= REAL_TO_TIME(rCycleTime_pom), rOut=> rCurrentF);
rTorqueF := rCurrentF * rTorqueConstant;

//=============== Save torque and current max values ===============
IF ABS(rCurrentMax) < ABS(rCurrentF) THEN
	rTorquePercMax						:= rTorquePerc;
	rCurrentMax 						:= rCurrentF;
	rTorqueMax							:= rTorqueF;
END_IF
//======================== Set outputs ==========================
rTorquePerc								:= LREAL_TO_REAL(Axis.NcToPlc.ActTorque); 		// [%]
rTorqueRAW 								:= rTorquePerc*10;								// -1000 .. 1000 - RAW values the same as process image


//=============== Oblicznie I2T ===============
//======== b_Flag_1 is set to TRUE when PLC cycle matches with algorythm sampling rate ========

IF rCycleTime <> 0 THEN
	IF iCycles < rCycleTime_pom/rCycleTime  THEN
		iCycles := iCycles + 1;
		bFlag_1 := FALSE;
	ELSE
		iCycles := 0;
		bFlag_1 := TRUE;
	END_IF
END_IF

(*Save momentary I2T values in ring buffer*)

IF bFlag_1 THEN
	FOR iCounter :=1 TO 99 DO
		rBuffer[iCounter] := rBuffer[iCounter+1];
		rBuffer_2[iCounter] := rBuffer_2[iCounter+1];
	END_FOR
	rBuffer[100] := rCurrentF *rCurrentF* rCycleTime_pom;
	rBuffer_2[100] := rWarningCurrent *rWarningCurrent* rCycleTime_pom;
END_IF

rI2T := 0;
rI2T_pom := 0;

(*Calculate I2T parameter*)

FOR iCounter:=1 TO 100 BY 1 DO
	rI2T := rI2T + rBuffer[iCounter];
	rI2T_pom := rI2T_pom + rBuffer_2[iCounter];
END_FOR

(*Scale I2T to 0-100% range*)

IF rI2T_pom  <> 0  THEN
	rI2T := rI2T/rI2T_pom*100;
END_IF

IF rI2TMax < rI2T THEN
	rI2TMax := rI2T;
END_IF

// Flaga Overcurrent (rCurrentF > rRatedCurrent)
bWarning := rCurrentF > rWarningCurrent;

IF bReset THEN
	rCurrentMax := 0;
	rTorqueMax := 0;
	rI2TMax := 0;
	FOR iCounter:=1 TO 100 BY 1 DO
		rBuffer[iCounter] := 0;
		rBuffer_2[iCounter] := 0;
	END_FOR;
END_IF

//========= Wywolanie bloku odczytu =========
fbSoERead(
	NetId:= '',
	Timeout:= T#1s,
	Axis:= Axis);
]]></ST>
    </Implementation>
    <LineIds Name="FB_MotorMonitoringAX5000">
      <LineId Id="2585" Count="17" />
      <LineId Id="2733" Count="0" />
      <LineId Id="2603" Count="107" />
      <LineId Id="2320" Count="0" />
      <LineId Id="2711" Count="0" />
      <LineId Id="2726" Count="4" />
      <LineId Id="2326" Count="0" />
      <LineId Id="2731" Count="0" />
      <LineId Id="2327" Count="17" />
      <LineId Id="2492" Count="0" />
      <LineId Id="2345" Count="2" />
      <LineId Id="2502" Count="1" />
      <LineId Id="2490" Count="1" />
      <LineId Id="2488" Count="0" />
      <LineId Id="2348" Count="61" />
      <LineId Id="2083" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>